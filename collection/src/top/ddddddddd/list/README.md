# ArrayList

## 构造函数

- ArrayList()：无参构造
  - 初始化长度为0的数组
- ArrayList(int initialCapacity)：指定容量构造
  - 初始化指定容量大小的数组
- ArrayList(Collection c)：指定集合构造
  - 初始化c的大小数组，并copy过去

## 扩容机制

- add(Object o)
  - 无参构造时：第一次add，会初始化大小为**10** 的数组
  - 数组容量满时：当数组已经存满，再add的时候，会扩容当前数组数量的**1.5** 倍。(n + n>>1)
- addAll(Collection c)
  - 指定集合构造时：会在10和c的大小中取最大的一个数来扩容（Math.max(**10,c.size()**)）
  - 已经存在大小的数组时：会取原容量的**1.5**倍和实际元素大小来取最大的一个数来扩容（Math.max(**原容量 1.5倍，c.size()**)）

## fail-fast 与 fail-safe

- **fail-fast**：一旦发现遍历的同时其他人来修改，则立刻抛异常
  - **ArrayList** 是 fail-fast的典型代表，遍历的同时不能修改，抛出并发修改的异常

- **fail-safe**：发现遍历的同时其它人来修改，应当能有应对策略，例如牺牲一致性来完成整个遍历运行完成
  - **CopyOnWriteArrayList** 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离

# LinkedList

### ArrayList与LinkedList比较

- ArrayList
  - 基于数组，需要连续内存
  - 随机访问快（指根据下标访问）
  - 尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低
  - 可以利用cpu缓存，局部性原理
- LinkedList
  - 基于双向链表，无需连续内存
  - 随机访问慢（要沿着链表遍历）
  - 头尾插入删除性能高
  - 占用内存多

# HashMap

- 底层数据结构，1.7与1.8有何不同？
  - 1.7：数组+链表
  - 1.8：数组+链表+红黑树
- 为什么要使用红黑树？
  - 红黑树用来避免Dos攻击，防止链表超长时性能下降，树化应当是偶然情况
- 为什么不直接树化？
  - hash表的查找，更新的时间复杂度是O(1)，而红黑树的查找，更新的时间复杂度是O(log2n)，TreeNode占用空间也比普通Node要大，如非必要，尽量还是使用链表
- 树化的阈值为什么是8？
  - hash值如果足够随机，则在hash表内按照泊松分布，在负载因子0.75的情况下，长度超过8的链表出现的概率极小，选择8就是为了让树化几率足够小
- 什么时候会树化？
  - 需要同时满足链表长度超过8个，数组容量>=64
- 什么时候会退化为链表？
  - 第一种情况：在扩容时如果拆分树时，树元素个数<= 6 则会退化为链表
  - 第二种情况：remov树节点时，如root、root.left、root.right、root.left.left有一个为 null，也会退化为链表

- 索引如何计算？
  - 计算对象的hasCode()，再进行调用HashMap的 hash()方法进行二次哈希，最后 mod 当前数组的容量得到索引
- hashCode都有了，为什么还要进行二次哈希？
  - 二次hash()是为了综合高维数据，让哈希分布更为均匀，**hash扰动**
- 数组容量为何是2的n次幂？
  - 计算所索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高
  - 扩容时可以快速计算出扩容后元素的移位规则，hash & oldCap == 0 的元素留在原位置，新位置 = 旧位置 + oldCap
  - 应该是设计者综合了各种因素，最终选择使用2的n次幂作为容量
- 介绍以下**put**方法流程，1.7与1.8有何不同？
  1. HashMap是懒惰创建数组的，首次使用才创建数组
  2. 计算索引（桶下标）
  3. 如果桶下标还没有人占用，创建Node占位返回
  4. 如果桶下标已经有人占用
    1. 已经是TreeNode 走红黑树的添加或更新逻辑
    2. 是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
  5. **返回前**检查容量是否超过阈值，一旦超过则进行扩容
  6. 1.7与1.8的不同
    1. 链表插入节点时，1.8是尾插法，1.7是头插法
    2. 1.7是大于等于阈值且没有空位时才会扩容，1.8是大于阈值就扩容
    3. 1.8再扩容计算Node索引时会优化

- 加载因子为何默认是 **0.75f**?
  - 在空间占用和查询时间之间取得较好的权衡
  - 大于这个值，空间节省了，但是链表就会比较长，影响性能
  - 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多

- 多线程下会有什么问题？

  - 扩容死链（1.7） 多线程扩容时，会造成node相互依赖造成死循环
  - 数据错乱（1.7 1.8）多线程put操作时，会造成创建Node占位时，覆盖情况，导致数据丢失

- key是否可以为 **null** ，作为 key 的对象有什么要求？

  - HashMap的 key 可以为 null，但是Map的其它实现则不可以
  - 做为key的对象，必须实现 hashCode 和 equals，并且key的内容不能修改（不可变）

- String 对象的 hashCode() 如何设计的，为什么每次都乘以 **31**？

  - 31代入公式有较好的散列特性，并且 31 * h 可以被优化为 移位运算效率远远大于乘法

    - 32 * h - h
    - 2的5次方 * h - h
    - 即 h << 5 - h















