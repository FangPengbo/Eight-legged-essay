#  设计模式

## 单例模式

- 饿汉式单例模式
    - 私有化构造参数
    - 提供静态变量
    - 提供静态方法返回静态变量
- 防止破坏单例的方法
    - 反射会破坏单例
        - 在构造方法中判断单例对象是否为null，抛出异常
    - 反序列化会破坏单例
        - 重写readResolve方法，返回单例对象
    - unsafe破坏单例
        - 无解

- 枚举饿汉式单例
    - 创建枚举类，只填写一个实例
- 懒汉式单例
    - 在getInstance时判断单例对象是否为空，不为空的时候才创建，再返回
    - **多线程**下，可能会导致单例失效，需要在getInstance添加**synchronized**关键字加锁来保证单例性
- 懒汉式单例-双检锁
    - 每次获取对象都要抢占锁，有资源的消耗
    - 在getInstance判断时，在里边加锁，加锁的时候再判断是否为空，不为空再创建，这样当对象创建之后，再获取的时候就不用抢占锁了
    - 在多线程的环境下，jvm会对**指令重排序** 这时候也会导致单例对象未被完全初始化就被拿出去用了，这时候需要在 **共享变量(单例对象)** 上加上 **volatile** 关键字，保证单例对象完全被初始化才可以被其它线程拿去用
- 懒汉式单例-静态内部类
    - 在单例类中写一个静态内部类，静态内部类声明静态的单例对象，在getInstance方法获取内部类的单例对象，这样即可以实现懒加载也可以保证线程的安全
- 在哪里有见过单例模式的实现？
    - Runtime.getRuntime()  -饿汉式
    - Collections.EMPTY_XXX -懒汉式
